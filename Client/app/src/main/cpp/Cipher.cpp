#include "Cipher.h"

Cipher::Cipher(const EVP_CIPHER *cipher_type)
{
	cipher_ctx = EVP_CIPHER_CTX_new();
	EVP_EncryptInit_ex(cipher_ctx, cipher_type, NULL, NULL, NULL);
}

Cipher::~Cipher()
{
	EVP_CIPHER_CTX_free(cipher_ctx);
}

void Cipher::Encrypt(unsigned char *ciphertext, int &cipher_len,
		const unsigned char *message, int message_len,
		const unsigned char *sym_key, const unsigned char *iv)
{
	int out_len = 0;
	
	EVP_EncryptInit_ex(cipher_ctx, NULL, NULL, sym_key, iv);
	EVP_EncryptUpdate(cipher_ctx, ciphertext, &out_len, message, message_len);
	cipher_len = out_len;
	EVP_EncryptFinal_ex(cipher_ctx, ciphertext + cipher_len, &out_len);
	cipher_len += out_len;
}

bool Cipher::Decrypt(unsigned char *message, int &message_len,
		const unsigned char *ciphertext, int cipher_len,
		const unsigned char *sym_key, const unsigned char *iv)
{
	int out_len = 0;

	EVP_DecryptInit_ex(cipher_ctx, NULL, NULL, sym_key, iv);
	EVP_DecryptUpdate(cipher_ctx, message, &out_len, ciphertext, cipher_len);
	message_len = out_len;
	EVP_DecryptFinal_ex(cipher_ctx, message + message_len, &out_len);
	message_len += out_len;

	return true;
}

void _test_Cipher()
{
	Cipher cipher(EVP_aes_256_ofb());

	unsigned char sym_key[32] = {
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
	};
	unsigned char iv[16] = {
		0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 
		0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04
	};
	unsigned char message[126] = {
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06
	};
	unsigned char dec_message[_MAX_BUFFER_SIZE];
	unsigned char buffer[_MAX_BUFFER_SIZE];
	int cipher_len, dec_message_len;

	bool flag;
	for (int i = 0; i < 1000; ++i)
	{
		cipher.Encrypt(buffer, cipher_len, message, 126, sym_key, iv);
		flag = cipher.Decrypt(dec_message, dec_message_len, buffer, cipher_len, sym_key, iv);
	}

	assert( (flag == true) &&
			(dec_message_len == 126) &&
			(strncmp((char *)message, (char *)dec_message, 126) == 0) );
}